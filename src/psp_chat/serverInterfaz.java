/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package psp_chat;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;

/**
 *
 * @author Mirroriced
 */
public class serverInterfaz extends javax.swing.JFrame {

    public ServerSocket serverSocket = null;
    public static ArrayList<Socket> lClientes = new ArrayList<Socket>();
    public static int contador = 0;
    public static boolean lleno;

    /**
     * Creates new form serverInterfaz
     */
    public serverInterfaz() {
        initComponents();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        cuerpoServidor = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED, java.awt.Color.black, new java.awt.Color(0, 0, 0), java.awt.Color.black, java.awt.Color.black));
        jPanel1.setForeground(new java.awt.Color(51, 51, 51));

        cuerpoServidor.setEditable(false);
        cuerpoServidor.setBackground(new java.awt.Color(248, 248, 248));
        cuerpoServidor.setColumns(20);
        cuerpoServidor.setFont(new java.awt.Font("Monospaced", 1, 14)); // NOI18N
        cuerpoServidor.setRows(5);
        jScrollPane1.setViewportView(cuerpoServidor);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 362, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 468, Short.MAX_VALUE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        //inicializamos interfaz
        serverInterfaz server = new serverInterfaz();
        server.setVisible(true);
        server.setDefaultCloseOperation(3);
        try {
            //realizamos la iniciación del serviodr
            cuerpoServidor.append("Creando socket servidor" + "\n");

            ServerSocket serverSocket = new ServerSocket();

            cuerpoServidor.append("Realizando el bind" + "\n");

            //pedimos por teclado el puerto a establecer
            int port = selecPuerto();

            InetSocketAddress addr = new InetSocketAddress("localhost", port);
            serverSocket.bind(addr);
            cuerpoServidor.append("Inicializando servicio en: localhost" + "\n");
            cuerpoServidor.append("Inicializando servicio en: " + port + "\n");

            cuerpoServidor.append("Aceptando conexiones" + "\n");
            cuerpoServidor.append("Ningún cliente conectado." + "\n");
            while (serverSocket != null) {

                //empezamos la conexión con el cliente y empezamos un hilo
                Socket newSocket = serverSocket.accept();
                cuerpoServidor.append("Conexión recibida" + "\n");
                
                //Limitamos las conexiones a 10, si se sobrepasa lleno se vuelve true
                // y suma el contador que posteriormente al cerrar sockets se restará.
                if (contador < 10) {
                    contador++;
                    lleno = false;
                } else {
                    contador++;
                    lleno = true;
                }
                serverInterfaz.Server hilo = server.new Server(newSocket, lClientes);
                hilo.start();

            }
        } catch (IOException ex) {
            Logger.getLogger(Server.class.getName()).log(Level.SEVERE, null, ex);
        }

    }

    //Método para escribir el puerto sin que sea posible escribir letras y con una longitud mayor a 2 y menor a 5
    public static int selecPuerto() {
        String puerto = JOptionPane.showInputDialog("Indique puerto donde alojar su servidor");
        int port = 0;
        if (puerto.length() >= 2 && puerto.matches("[0-9]+") && puerto.length() <= 4) {
            port = Integer.parseInt(puerto);
        } else {
            JOptionPane.showMessageDialog(null, "Escriba un puerto correcto");
            port = selecPuerto();
        }
        return port;
    }

    //clase interna que usaremos como hilo.
    class Server extends Thread {

        public Socket clientSocket = null;
        public DataInputStream entradaCli = null;
        public DataOutputStream salidaCli = null;

        public Server(Socket socket, ArrayList<Socket> lClientes) {
            clientSocket = socket;
            serverInterfaz.lClientes = lClientes;
            lClientes.add(clientSocket);
        }

        public void run() {

            try {

                //Marcamos que el cliente está conectado
                boolean conectado = true;

                //Abrimos la entrada para recibir los mensajes del cliente
                entradaCli = new DataInputStream(new BufferedInputStream(clientSocket.getInputStream()));
                salidaCli = new DataOutputStream(clientSocket.getOutputStream());

                //tratamos el limite de clientes, si está lleno envia mensaje "lleno" y desconecta
                //si no lo está envía nolleno y continua.
                if (lleno) {
                    salidaCli.writeUTF("lleno");
                    conectado = false;
                }
                salidaCli.writeUTF("nolleno");
                //Recogemos el nombre de usuario y indicamos que se ha conectado
                String usuario = "";
                try {
                    usuario = entradaCli.readUTF();
                    String ip = entradaCli.readUTF();
                    int port = entradaCli.readInt();
                    cuerpoServidor.append("Nuevo cliente conectado(" + usuario + " / " + ip + " / " + port + ")" + "\n");
                    cuerpoServidor.append("Actualmente hay " + lClientes.size() + " usuarios conectados." + "\n");

                    //Mandamos a todos los clientes que el usuario se ha conectado
                    cuerpoServidor.append(usuario + " acaba de conectarse a este chat" + "\n");
                    String conecta = entradaCli.readUTF();
                    broadcastStatus(conecta);

                    while (conectado) {
                        //Mientras esté el cliente el servidor recibirá el texto y lo devolverá a todos los usuarios
                        String mensaje = entradaCli.readUTF();
                        if (!mensaje.equals("/bye")) {
                            //Si el texto no es /bye se muestra el mensaje junto con el nombre de usuario
                            broadcast(mensaje, usuario);
                            cuerpoServidor.append(usuario + ":" + mensaje + "\n");
                        } else {
                            //si es /bye el boolean se vuelve false y desconectamos
                            conectado = false;
                        }
                    }

                    //Broadcast de desconexion
                    conecta = entradaCli.readUTF();
                    broadcastStatus(conecta);
                    //Indicamos que el usuario se desconecta y cerramos la entrada.
                    cuerpoServidor.append(usuario + " abandonó este chat" + "\n");
                    //Quitamos de la lista el socket cliente
                    lClientes.remove(clientSocket);
                    // si no hay ningun cliente lo indicamos
                    if (lClientes.size() == 0) {
                        cuerpoServidor.append("Ningún cliente conectado." + "\n");
                    }
                    contador--;
                    entradaCli.close();
                    clientSocket.close();
                    //Tratamos excepción de si al escribir el usuario se cancela acción.
                } catch (Exception usercancel) {
                    cuerpoServidor.append("Conexión rechazada" + "\n");
                    contador--;
                    lClientes.remove(clientSocket);
                    entradaCli.close();
                    clientSocket.close();
                }
            } catch (IOException ex) {
                lClientes.remove(clientSocket);
                Logger.getLogger(Server.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        //Método para reenviar el mensaje recibido de un cliente a todos.
        //Iteramos el ArrayList de Sockets para enviar a cada uno de los clientes el mensaje (Socket)
        public void broadcast(String mensaje, String usuario) {

            try {
                for (Socket cliente : lClientes) {
                    String mensaje2 = usuario + ": " + mensaje;
                    salidaCli = new DataOutputStream(cliente.getOutputStream());
                    salidaCli.writeUTF(mensaje2);
                }
                salidaCli.flush();

            } catch (IOException ex) {
                Logger.getLogger(Server.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        //Método para reenviar la conexión/desconexión de los clientes.
        public void broadcastStatus(String mensaje) {

            try {
                for (Socket cliente : lClientes) {
                    salidaCli = new DataOutputStream(cliente.getOutputStream());
                    salidaCli.writeUTF(mensaje);
                }
                salidaCli.flush();

            } catch (IOException ex) {
                Logger.getLogger(Server.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private static javax.swing.JTextArea cuerpoServidor;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
}
